<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Module dflow</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module dflow</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>     
This is a flow processing library which aims to make it easy to     
write streamed routines for processing data.
<p>Copyright © (C) 2014, Heinz Nikolaus Gies</p>

<p><b>Behaviours:</b> <a href="gen_server.html"><tt>gen_server</tt></a>.</p>
<p><b>This module defines the <tt>dflow</tt> behaviour.</b><br> Required callback functions: <tt>init/1</tt>, <tt>describe/1</tt>, <tt>start/2</tt>, <tt>emit/3</tt>, <tt>done/2</tt>.</p>
<p><b>Authors:</b> Heinz Nikolaus Gies (<a href="mailto:heinz@licenser.net"><tt>heinz@licenser.net</tt></a>).</p>

<h2><a name="description">Description</a></h2><p>     
This is a flow processing library which aims to make it easy to     
write streamed routines for processing data.</p>
  
     <p>Each step in the process is handled as a own server allowing them     
to work indipendantly and take advantage of multi core sytems.</p>
  
     <p>Most opperations are handled in a asyncronous fashion to prevent     
a slower process from blocking it's children, however to prevent     
unbounded message queue growth the emit changes to syncornous     
mode guaranteeing a maximal queue length of     
(max_q_len) + (num_children).</p>
  
     <p>The steps of a flow need to implement the dflow behaviour.</p>
  
  
   <p>The <em>dflow</em> behaviour requires the following callbacks:</p>
  
   <pre>
   init(Args :: [term()]) -&gt;
      {ok, State :: term(), ChildSteps :: child_steps()}.
   </pre>
  
   <p>Called as part of <a href="#build-2"><code>build/2</code></a>, must return a initial state
   as well as its <a href="#type-child_steps"><code>child_steps()</code></a>.</p>
  
   <p>To simplify matters the child reference can be obmitted or if   
only a single item is the child only this item can be returned   
without wrapping it in a list.</p>
  
   <p>When references are provided for child steps the <em>emit</em>
   and <em>done</em> events will carry those refs even when a child   
links to multiple parents.</p>
  
   <pre>
   describe(State :: term()) -&gt;
      Description :: iodata().
   </pre>
  
   <p>Called as part of <a href="#describe-1"><code>describe/1</code></a> must return a description of   
the step.</p>
  
   <p>A simple example is just a human readable name but runtime data   
can be included.</p>
  
   <pre>
   start(Payload :: term(), State :: term()) -&gt;
      <a href="#type-dflow_return"><code>dflow_return()</code></a>.
   </pre>
  
   <p>Called as part of <a href="#start-2"><code>start/2</code></a>, however child processes only
   are triggered when <b>all</b> the parent processses linking   
to them are started.</p>
  
   <p>This is done to guarantee no child is started untill all the   
parents it will emit data to are ready.</p>
  
   <p>However order between different children is not guaranteed!</p>
  
   <pre>
   emit(Child :: reference(), Data :: term(), State :: term()) -&gt;
      <a href="#type-dflow_return"><code>dflow_return()</code></a>.
   </pre>
  
   <p>A child of the step emitted data, the data and the current state   
is passed.</p>
  
   <p>Erlang guarantees ordered delivery between two processes, so   
emits from a single child will arrive in the order they are generatd   
however the order amongst children is not guaranteed.</p>
  
   <p>The <em>Child</em> reference can be used to identify the child.</p>
  
   <pre>
   done(Child :: reference()| {last, Child :: reference()}, State :: term()) -&gt;
      <a href="#type-dflow_return"><code>dflow_return()</code></a>.
   </pre>
  
   <p>This is called when a child process singals that it's work is done.</p>
  
   <p>The <em>Child</em> reference can be used to identify the child.</p>
  
   <p>The DFlow keeps track of the children that are done with their work
   and the last <em>done</em> message will have a touple as child in
   the form <em>{last, Child :: reference()}</em>. This will signal that   
all children now have finished and there will be no more downstream   
work.</p>
  
   The <em>done</em> event does <b>not</b> indicate termination of the
   process unless the <em>terminate_when_done</em> option was passed.
  
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-dflow_return">dflow_return()</a></h3>
<p><tt>dflow_return() = {ok, State} | {emit, Data, State} | {done, Data, State} | {done, State}</tt>
<ul class="definitions"><li><tt>Data = term()</tt></li><li><tt>State = term()</tt></li></ul></p>
<p><p>The dflow behaviour callbacks <em>start/2</em>, <em>emit/3</em>,
  and <em>done/2</em> all return the <a href="#type-dflow_return"><code>dflow_return()</code></a> type.</p>
 
  <p><em>State</em> in any case will be the state passed to the next  
invocation of the callback module.</p>
 
  Depending on the exact return different actions are taken:
  <ul>
    <li><em>{ok, State}</em> - no additional actions are performed</li>
    <li><em>{emit, Data, State}</em> - The <em>Data</em> is emitted
        to <b>all</b> parents of this step.</li>
    <li><em>{done, Data, State}</em> - The <em>Data</em> is emitted
        to <b>all</b> parents of this step. <b>After</b> this <b>all</b>
        parents are informed at this step has finished.</li>
    <li><em>{done, Data}</em> - <b>All</b> parents are informed at this
        step has finished.</li>
  </ul>
 </p>

<h3 class="typedecl"><a name="type-flow_optsions">flow_optsions()</a></h3>
<p><tt>flow_optsions() = optimize | terminate_when_done | {max_q_len, MaxQLen}</tt>
<ul class="definitions"><li><tt>MaxQLen = pos_integer() | infinity</tt></li></ul></p>
<p><p>Configuration options that can be passed to DFlow to control how it  
builds the process tree or graph.</p>
 
  <ul>
    <li><em>optimize</em> - When optimize is passed the dflow library
        will try to optimize the call graph.</li>
    <li><em>terminate_when_done</em> - Will terminate the process after
        it signals being done.</li>
    <li><em>max_q_len</em> - This decide determine at what point a
        step switches from asyncronously passing messages to it's
        pareent to syncronously. If set to <em>infinity</em> the
        risk exists that the parents message box grows unbounded.<br>
        When set the parents message box will not grow lager then
        <em>num_children</em> + <em>max_q_len</em>.</li>
  </ul>
 
  <p>The algorithm is pretty basic. When the tree contains two equal branches,  
instead of spawing pme processes for each it will just link the top most  
common process to all parents consuming fro it.</p>
 
  A simple example where we have two flow steps:
  <ul>
    <li>+ - adds it's children</li>
    <li>N - emits the number N</li>
  </ul>
  unoptimized we'd get three processes:
  <pre>
        +
       / \
      1   1
  </pre>
  When optimized DFlow will recognoze that <em>1</em> is used twice and
  combine those two:
  <pre>
        +
       / \
       \ /
        1
  </pre>
 
  <p>The <em>+</em> process will still receive two numbers however instead  
of generating them twice they are only generated once.</p>
 
  Two branches are considered euqal when both the module and all it's
  arguments are equal.
 </p>

<h3 class="typedecl"><a name="type-step">step()</a></h3>
<p><tt>step() = {Module, Args}</tt>
<ul class="definitions"><li><tt>Module = atom()</tt></li><li><tt>Args = [term()]</tt></li></ul></p>
<p><ul>
    <li><em>Module</em> - The module that executes this step, needs
        to implement the dflow behaviour</li>
    <li><em>Args</em> - A list of arguments passed to the init/1
        call to <em>Module</em></li>
  </ul>
 
  <p>Every flow is represented as a step, this steps are then used  
by eflow to generate a graph of processes with each process  
representing one step.</p>
 
 </p>

<h3 class="typedecl"><a name="type-step_desc">step_desc()</a></h3>
<p><tt>step_desc() = {StepPid, Desc, Children}</tt></p>
<p><p>StepPid = pid(),    
Desc = iodata(),    
Children = [step_desc()}.</p>
 
  <p>This is used to describe the flow. The <em>StepPid</em> can be used
  as a unique identifyer for each step. Even when the <em>optimize</em>  
was passed as a argument during create time the descripion is build  
fully showing each link!</p>
 
  <p>Desc is a human readable string for each step, combined of the  
description given from the callback module and IO data gathered by  
DFlow itself.</p>
 
  The main purpose of this data is to be passed
  to <a href="#desc_to_graphvix-1"><code>desc_to_graphvix/1</code></a> however it can be used for other tasks
  as well.
 </p>

<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#build-1">build/1</a></td><td>See <a href="#build-2"><code>build/2</code></a> with <em>Options</em> set to [optmize].</td></tr>
<tr><td valign="top"><a href="#build-2">build/2</a></td><td>Builds a flow process tree or graph based the <em>Head</em>
  and the <em>Options</em> passed.</td></tr>
<tr><td valign="top"><a href="#desc_to_graphvix-1">desc_to_graphvix/1</a></td><td>Translates the output from <a href="#describe-1"><code>describe/1</code></a> to a graphviz
  dot file.</td></tr>
<tr><td valign="top"><a href="#describe-1">describe/1</a></td><td>Traverses the process tree to give a representation of it's  
layout including IO counters and other information provided by  
each process.</td></tr>
<tr><td valign="top"><a href="#start-2">start/2</a></td><td>Sends a start signal to the Flow.</td></tr>
<tr><td valign="top"><a href="#terminate-1">terminate/1</a></td><td>Terminates a Flow.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="build-1">build/1</a></h3>
<div class="spec">
<p><tt>build(Head::<a href="#type-step">step()</a>) -&gt; {ok, Ref, Pid}</tt><br></p>
</div><p>See <a href="#build-2"><code>build/2</code></a> with <em>Options</em> set to [optmize].
 </p>

<h3 class="function"><a name="build-2">build/2</a></h3>
<div class="spec">
<p><tt>build(Head::<a href="#type-step">step()</a>, Options::[<a href="#type-flow_options">flow_options()</a>]) -&gt; {ok, Ref::reference(), Pid::pid()}</tt><br></p>
</div><p><p>Builds a flow process tree or graph based the <em>Head</em>
  and the <em>Options</em> passed. It returns the <em>Ref</em> the  
calling process should know this process as when dealing with it as  
a flow child.</p>
 
 </p>

<h3 class="function"><a name="desc_to_graphvix-1">desc_to_graphvix/1</a></h3>
<div class="spec">
<p><tt>desc_to_graphvix(Description::<a href="#type-step_desc">step_desc()</a>) -&gt; DotData::iodata()</tt><br></p>
</div><p>Translates the output from <a href="#describe-1"><code>describe/1</code></a> to a graphviz
  dot file.
 </p>

<h3 class="function"><a name="describe-1">describe/1</a></h3>
<div class="spec">
<p><tt>describe(Head::pid()) -&gt; Desc::<a href="#type-step_desc">step_desc()</a></tt><br></p>
</div><p><p>Traverses the process tree to give a representation of it's  
layout including IO counters and other information provided by  
each process.</p>
 
 </p>

<h3 class="function"><a name="start-2">start/2</a></h3>
<div class="spec">
<p><tt>start(Head::pid(), Payload::term()) -&gt; ok</tt><br></p>
</div><p><p>Sends a start signal to the Flow. The start signal is send  
asyncronous so the order is not guaranteed, however a child will  
not get the start message until it's it's parents are started and  
it will get it only once.</p>
 
  The <em>Payload</em> passed will be handed to each flow process
  that is started and stays unmodified throughout the entire call
  chain.
 </p>

<h3 class="function"><a name="terminate-1">terminate/1</a></h3>
<div class="spec">
<p><tt>terminate(Head::pid()) -&gt; ok</tt><br></p>
</div><p><p>Terminates a Flow. This can only be called on the <em>Head</em>  
of the flow, it will terminate the process by using the dflow_sup  
supervisor and propagate the terminate by the links to the children.</p>
 
 </p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, Dec 14 2014, 15:23:50.</i></p>
</body>
</html>
